#!/usr/bin/python3
"""
Remove isomorphic cubes for multiple tables



To generate cubes:
date; build/mace4 -n7 -N7 -m-1 -A1 -C16 -O3 -f inputs/semi.in > working/16.out; date
The models generated in this step must be kept


The cubes are of the format (the first number is num cells filled, -1 if not calculated)
4 0 0 0 0 %c%<canonical graph>
4 0 0 1 1 %c%<canonical graph>
9 0 0 2 2 %c%<canonical graph>
4 0 1 0 0 %c%<canonical graph>


"""

import sys
import subprocess
import threading
import time
import copy
import json
from itertools import permutations


def thread_available(thread_count, thread_slots):
    for x in range(thread_count):
        if thread_slots[x] == 0:
            return x
    return -1


def all_done(thread_slots):
    for x in range(len(thread_slots)):
        if thread_slots[x] != 0:
            return False
    return True

"""
def run_process(id, slot_id, thread_slots, order, cube_length, input_file, cube, print_models, mace4, working_dir):
    working_dir = f"{working_dir}_{slot_id}"
    os.makedirs(working_dir, exist_ok=True)
    
    if cube is not None:
        with (open(f"{working_dir}/cube.config", "w")) as fp:
            for x in cube:
                fp.write(f"{x}\n")

    # print(f"************************************ {cube}")
    subprocess.run(f"cd {working_dir}; {mace4} -n{order} -N{order} -m-1 -{print_models} -C{cube_length} -O3 -f {input_file} >> {cube_length}.out 2>>mace.out", 
                    capture_output=False, text=True, check=False, shell=True)      # ; mv models.out {id}.out",
    #if cp.returncode != 0:
    #    with( open("mace.log", "a")) as fp:
    #        fp.write(f"return code: {cp.returncode}\n\n")
        #raise RuntimeError(f"Failed mace4 {cube}\n")
    thread_slots[slot_id] = 0
"""


def run_process(id, slot_id, thread_slots, cubes, is_relation, all_permutations, seq, iso_cubes_exec):
    params = {'cubes': cubes, 'is_relation': is_relation, 'all_permutations': all_permutations}
    params_json = json.dumps(params)
    
    cp = subprocess.run(iso_cubes_exec, input=params_json.encode('utf-8'), stdout=subprocess.PIPE, shell=True)      # ; mv models.out {id}.out",
    out_json = json.loads(cp.stdout.decode('utf-8'))
    non_iso_cubes = [[tuple([tuple([y[0][0], tuple(y[0][1])]), y[1]]) for y in x] for x in out_json]
    # if len(cubes) != len(non_iso_cubes):
    #     print(f"******{len(cubes}********cut down to********{len(non_iso_cubes)}")
    seq.extend(non_iso_cubes)
    thread_slots[slot_id] = 0


def run_process_multi(id, slot_id, thread_slots, blocks, is_relation, all_permutations, seq, iso_cubes_exec_multi):
    hash_values = [x[1] for x in blocks]
    params = {'blocks': hash_values, 'is_relation': is_relation, 'all_permutations': all_permutations}
    params_json = json.dumps(params)
    # print(f"debug run_process_multi ^^^^^^^^^^^^^^^{params_json}^^^^^^^^^^^^")
    
    cp = subprocess.run(iso_cubes_exec_multi, input=params_json.encode('utf-8'), stdout=subprocess.PIPE, shell=True)      # ; mv models.out {id}.out",
    # print(f"^^^^^^^^^^^^^^^{cp.stdout}^^^^^^^^^^^^")
    out_json = json.loads(cp.stdout.decode('utf-8'))
    # non_iso_cubes = [[tuple([tuple([y[0][0], tuple(y[0][1])]), y[1]]) for y in x] for x in out_json]
    non_iso_cubes = [tuple([[tuple([tuple([y[0][0], tuple(y[0][1])]), y[1]]) for y in x[0]], x[1]]) for x in out_json]
    # if len(cubes) != len(non_iso_cubes):
    #     print(f"******{len(cubes}********cut down to********{len(non_iso_cubes)}")
    seq.extend(non_iso_cubes)
    thread_slots[slot_id] = 0


def gen_sequence( in_cubes_filepath, out_cubes_filepath, max_threads=8):
    """
        A cube is represented by a list of (cell term, value), and in addition, there is a number of cells filled for each cube.
    Args:
        n (int): order of the algebra
        cube_length (int): length of the search sequence
        radius (int): radius of the cube
        arities (List[int]): arity of each function
        is_relation (List[bool]): True if if the function symbol is a relation
        all_permutations:
        inv_threshold (int): use invariants if there are at least inv_threshold models
        iso_cubes_exec (str): path of python secript to filter isomoprhic cubes
        prev_cubes_filepath (str): file path of a file containing all cubes of shorter length to build on
        in_cubes_filepath (str): file path of the file containing the cubes generated by Mace4
        out_cubes_filepath (str): file for output cubes of length "cube_length"
        all_permutations (List[List[int, int]]): list of permutations
    """    
    print(f"debug gen_sequence ********************* {in_cubes_filepath}")

    full_cubes_str = read_cubes_file(in_cubes_filepath)
    
    # print(f"***** {cube_length}")
    non_iso_cubes = set()
    with (open(out_cubes_filepath, "w")) as fp:
        for cube_str in full_cubes_str:
            (cube, cg) = cube_str.split("%c%")
            if cg not in non_iso_cubes:
                non_iso_cubes.add(cg);
                fp.write (cube)
                fp.write ("\n")

    print(f"debug gen_sequence, incoming number of cubes: {len(full_cubes_str)}, Non-iso: {len(non_iso_cubes)}", flush=True)


def read_cubes_file(file_path):
	with (open(file_path)) as fp:
		p = fp.read().splitlines()
	# print(p)
	return p


def write_purged_cubes(file_path, cubes):
	with (open(file_path, "w")) as fp:
		json.dump(cubes, fp)


def print_short(cube):
	y = [str(x[1]) for x in cube]
	print("-".join(y))
	

__all__ =["gen_sequence"]


if __name__ == "__main__":
    inv_threshold = 10000
    iso_cubes_exec = './iso_cubes.py'

